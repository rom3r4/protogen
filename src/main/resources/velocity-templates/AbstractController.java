package ${packageName};

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.ModelAttribute;

import edu.uiowa.icts.datatable.DataTable;
import ${daoPackageName}.${daoServiceClassName};
import edu.uiowa.icts.spring.GenericDaoListOptions;
import edu.uiowa.icts.util.DataTableHeader;
import edu.uiowa.icts.util.SortColumn;

/**
 * Generated by Protogen
 * @since ${date}
 */
public abstract class ${abstractControllerClassName} {

	protected ${daoServiceClassName} ${daoServiceVariableName};

	@Autowired
	public void set${daoServiceClassName}( ${daoServiceClassName} ${daoServiceVariableName} ) {
		this.${daoServiceVariableName} = ${daoServiceVariableName};
	}

	@ModelAttribute( value = "username" )
	public String getUsername() {
		return SecurityContextHolder.getContext().getAuthentication().getName();
	}

	/**
	 * @param e
	 * @param draw
	 * @return {@link DataTable}
	 */
	protected DataTable datatableError( Exception e, String draw ) {
		String stackTrace = e.getMessage() + String.valueOf( '\n' );
		for ( StackTraceElement ste : e.getStackTrace() ) {
			stackTrace += ste.toString() + String.valueOf( '\n' );
		}
		DataTable error = new DataTable();
		error.setDraw( draw );
		error.setRecordsFiltered( 0 );
		error.setRecordsTotal( 0 );
		error.setError( stackTrace );
		return error;
	}

	/**
	 * @param request
	 * @param columnCount
	 * @return {@link List} of {@link DataTableHeader}
	 */
	protected List<DataTableHeader> headers( HttpServletRequest request, Integer columnCount ) {
		List<DataTableHeader> headers = new ArrayList<DataTableHeader>();
		for ( int i = 0; i < columnCount; i++ ) {
			DataTableHeader dth = new DataTableHeader();
			dth.setData( request.getParameter( "columns[" + i + "][data]" ) );
			dth.setName( request.getParameter( "columns[" + i + "][name]" ) );
			dth.setOrderable( Boolean.valueOf( request.getParameter( "columns[" + i + "][orderable]" ) ) );
			dth.setSearchable( Boolean.valueOf( request.getParameter( "columns[" + i + "][searchable]" ) ) );
			dth.setSearchValue( request.getParameter( "columns[" + i + "][search][value]" ) );
			dth.setSearchRegex( Boolean.valueOf( request.getParameter( "columns[" + i + "][search][regex]" ) ) );
			headers.add( dth );
		}
		return headers;
	}

	/**
	 * @param request
	 * @param columnCount
	 * @param headers
	 * @return {@link ArrayList} of {@link SortColumn}
	 */
	protected ArrayList<SortColumn> sortColumns( HttpServletRequest request, Integer columnCount, List<DataTableHeader> headers ) {
		ArrayList<SortColumn> sorts = new ArrayList<SortColumn>();
		for ( int i = 0; i < columnCount; i++ ) {
			Integer columnIndex = null;
			String columnIndexString = request.getParameter( "order[" + i + "][column]" );
			if ( columnIndexString != null ) {
				try {
					columnIndex = Integer.parseInt( columnIndexString );
				} catch ( NumberFormatException e ) {
					continue;
				}
				if ( columnIndex != null && columnIndex < headers.size() ) {
					String direction = request.getParameter( "order[" + i + "][dir]" );
					String name = headers.get( columnIndex ).getName();
					sorts.add( new SortColumn( name, direction == null ? "asc" : direction ) );
				}
			}
		}
		return sorts;
	}

	/**
	 * @param options
	 * @param headers
	 * @param columnCount
	 * @param individualSearch
	 * @param search
	 */
	protected void searchCriteria( GenericDaoListOptions options, List<DataTableHeader> headers, Integer columnCount, Boolean individualSearch, String search ) {
		if ( !individualSearch ) {
			ArrayList<String> searchColumns = new ArrayList<String>();
			for ( int i = 0; i < columnCount; i++ ) {
				if ( headers.get( i ).getSearchable() ) {
					String name = headers.get( i ).getName();
					searchColumns.add( name );
				}
			}
			options.setSearch( search );
			options.setSearchColumns( searchColumns );
		} else {
			Map<String, List<Object>> likes = new HashMap<String, List<Object>>();
			for ( DataTableHeader header : headers ) {
				String name = header.getName();
				if ( header.getSearchable() && header.getSearchValue() != null ) {
					List<Object> values = new ArrayList<Object>();
					for ( String splitColumnValue : StringUtils.split( header.getSearchValue().trim(), ' ' ) ) {
						values.add( splitColumnValue.trim() );
					}
					likes.put( name, values );
				}
			}
			options.setLikes( likes );
		}
	}

}